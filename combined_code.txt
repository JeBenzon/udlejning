
--- File: postcss.config.mjs ---

const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;

--- File: content.config.ts ---


--- File: next-env.d.ts ---

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.

--- File: package.json ---

{
  "name": "udlejning",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@radix-ui/react-dialog": "^1.1.13",
    "@radix-ui/react-hover-card": "^1.1.13",
    "@radix-ui/react-label": "^2.1.6",
    "@radix-ui/react-slot": "^1.2.2",
    "@tailwindcss/vite": "^4.1.6",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "gray-matter": "^4.0.3",
    "lucide-react": "^0.510.0",
    "next": "^15.3.2",
    "next-mdx-remote": "^5.0.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "tailwind-merge": "^3.3.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@shadcn/ui": "^0.0.4",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^22.15.17",
    "@types/react": "^19.1.4",
    "@types/react-dom": "^19.1.4",
    "eslint": "^9",
    "eslint-config-next": "15.3.2",
    "tailwindcss": "^4.1.6",
    "tw-animate-css": "^1.2.9",
    "typescript": "^5.8.3"
  }
}

--- File: components.json ---

{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
--- File: tsconfig.json ---

{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts", ".contentlayer/generated"],
  "exclude": ["node_modules"]
}

--- File: vite.config.ts ---

import { defineConfig } from 'vite'
import tailwindcss from '@tailwindcss/vite'
export default defineConfig({
  plugins: [
    tailwindcss(),
  ],
})
--- File: eslint.config.mjs ---

import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;

--- File: next.config.ts ---

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
  // Add this block to ignore TypeScript errors during build
  typescript: {
    ignoreBuildErrors: false,
  },
};

// export default withContentlayer(nextConfig);
export default nextConfig;

--- File: content/products/plate-vibrator.mdx ---

---
name: Plate Vibrator 80kg hehe
description: >-
  Powerful and reliable plate vibrator for compacting soil, asphalt, and paving
  stones. Easy to operate.
category: Compaction Equipment
dailyPrice: 250
weekendPrice: 600
weeklyPrice: 1200
deposit: 500
---

## Product Specifications

Detailed information about the plate vibrator...

- Weight: 80kg
- Compaction Force: ...
- Engine: ...

## Usage Instructions

How to safely operate the machine...

--- File: content/products/test.mdx ---

---
name: test
description: test
category: test
dailyPrice: 1234
weekendPrice: 1234
weeklyPrice: 124
deposit: 200
---
## Product Specifications

## Usage Instructions
21312

--- File: src/app/layout.tsx ---

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}

--- File: src/app/page.tsx ---

import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';
import { ProductSearch } from '@/components/product-search';
// Note: The 'Product' type will now implicitly come from whatever ProductSearch expects,
// or we can define it here if needed. For now, we'll ensure the shape matches.

const productsDirectory = path.join(process.cwd(), 'content/products');
const imagesBaseDirectory = path.join(process.cwd(), 'public/images/products'); // Path to product images root
const imagesPublicPath = '/images/products'; // Public URL path

// Function to get sorted image URLs (can be shared or duplicated from [slug]/page.tsx)
function getProductImages(slug: string): string[] {
  const productImageDir = path.join(imagesBaseDirectory, slug);
  try {
    if (!fs.existsSync(productImageDir)) {
      return [];
    }
    const imageFilenames = fs.readdirSync(productImageDir);
    const sortedImageFiles = imageFilenames
      .filter(filename => /\.(jpg|jpeg|png|webp|gif)$/i.test(filename))
      .sort((a, b) => a.localeCompare(b));
    return sortedImageFiles.map(filename => `${imagesPublicPath}/${slug}/${filename}`);
  } catch (error) {
    console.error(`Error reading images for product ${slug} in getAllProducts:`, error);
    return [];
  }
}

// Define a type for the product data we will extract
// This should match the structure ProductSearch and ProductCard expect
interface ProductData {
  slug: string;
  name: string;
  description: string;
  category: string;
  imageUrls: string[]; // Added imageUrls
  dailyPrice: number;
  // Add other fields if ProductSearch/ProductCard use them, e.g., weekendPrice, weeklyPrice
}

async function getAllProducts(): Promise<ProductData[]> {
  try {
    const filenames = fs.readdirSync(productsDirectory);
    const products = filenames
      .filter(filename => filename.endsWith('.mdx'))
      .map((filename) => {
        const slug = filename.replace(/\.mdx$/, '');
        const fullPath = path.join(productsDirectory, filename);
        try {
          const fileContents = fs.readFileSync(fullPath, 'utf8');
          const { data } = matter(fileContents);
          const imageUrls = getProductImages(slug);

          // Validation (check frontmatter WITHOUT requiring images)
          if (!data.name || !data.description || typeof data.dailyPrice !== 'number' || !data.category) {
            console.warn(`Skipping ${filename} due to missing required frontmatter for product listing.`);
            return null;
          }

          return {
            slug,
            name: data.name,
            description: data.description,
            category: data.category,
            imageUrls, // Pass empty array if no images found
            dailyPrice: data.dailyPrice,
          } as ProductData;
        } catch (readError) {
          console.error(`Error reading or parsing ${filename}:`, readError);
          return null;
        }
      });

    return products.filter(product => product !== null) as ProductData[];
  } catch (error) {
    console.error("Error reading products directory for getAllProducts:", error);
    return [];
  }
}


export default async function Home() {
  const allProducts = await getAllProducts();
  console.log("Fetched products for homepage:", allProducts);

  return (
    <div className="container mx-auto px-4 py-8">
      <header className="mb-8">
        <h1 className="text-3xl font-bold mb-6">Machine Rental</h1>
      </header>

      <section>
        <h2 className="text-2xl font-semibold mb-4">Available Equipment</h2>
        {/* The 'products' prop of ProductSearch now expects an array of ProductData */}
        <ProductSearch products={allProducts} />
      </section>
    </div>
  );
}

--- File: src/app/products/[slug]/page.tsx ---

import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';
import { MDXRemote } from 'next-mdx-remote/rsc';
import Image from 'next/image';
import { formatCurrency } from '@/lib/utils';
import { notFound } from 'next/navigation';

const productsDirectory = path.join(process.cwd(), 'content/products');
const imagesBaseDirectory = path.join(process.cwd(), 'public/images/products'); // Path to product images root
const imagesPublicPath = '/images/products'; // Public URL path

// Function to get sorted image URLs for a specific product slug
function getProductImages(slug: string): string[] {
  const productImageDir = path.join(imagesBaseDirectory, slug);
  try {
    if (!fs.existsSync(productImageDir)) {
      console.warn(`Image directory not found for product: ${slug} at ${productImageDir}`);
      return []; // No images if directory doesn't exist
    }
    const imageFilenames = fs.readdirSync(productImageDir);
    // Filter for common image extensions and sort alphabetically
    const sortedImageFiles = imageFilenames
      .filter(filename => /\.(jpg|jpeg|png|webp|gif)$/i.test(filename))
      .sort((a, b) => a.localeCompare(b)); // Sort alphabetically

    // Return full public paths
    return sortedImageFiles.map(filename => `${imagesPublicPath}/${slug}/${filename}`);
  } catch (error) {
    console.error(`Error reading images for product ${slug}:`, error);
    return []; // Return empty on error
  }
}

export async function generateStaticParams() {
  try {
    const filenames = fs.readdirSync(productsDirectory);
    return filenames
      .filter((filename) => filename.endsWith('.mdx')) // Ensure we only consider .mdx files
      .map((filename) => ({
        slug: filename.replace(/\.mdx$/, ''), // Remove .mdx extension for the slug
      }));
  } catch (error) {
    console.error("Error reading products directory for generateStaticParams:", error);
    return []; // Return empty array on error
  }
}

async function getProductBySlug(slug: string) {
  const fullPath = path.join(productsDirectory, `${slug}.mdx`);
  try {
    const fileContents = fs.readFileSync(fullPath, 'utf8');
    const { data, content } = matter(fileContents);

    // Fetch associated images
    const imageUrls = getProductImages(slug);

    // Validation (check frontmatter and ensure at least one image exists if required)
    if (!data.name || !data.description || typeof data.dailyPrice !== 'number' || typeof data.weekendPrice !== 'number' || typeof data.weeklyPrice !== 'number' || typeof data.deposit !== 'number' || imageUrls.length === 0) {
        console.error(`Missing required frontmatter fields or no images found in ${slug}.mdx`);
        return null;
    }

    return {
      slug,
      frontmatter: data as {
        name: string;
        description: string;
        category: string;
        // imageUrl: string; // Removed imageUrl
        dailyPrice: number;
        weekendPrice: number;
        weeklyPrice: number;
        deposit: number;
      },
      imageUrls, // Add the list of image URLs
      content,
    };
  } catch (error) {
    console.error(`Error reading product file ${slug}.mdx:`, error);
    return null;
  }
}

export default async function ProductPage({ params }: { params: { slug: string } }) {
  const product = await getProductBySlug(params.slug);

  if (!product) {
    notFound();
  }

  const { frontmatter, imageUrls, content } = product;
  const primaryImageUrl = imageUrls[0]; // Use the first image as primary

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
        <div className="relative aspect-square">
          {/* Use the primary image URL */}
          <Image
            src={primaryImageUrl}
            alt={frontmatter.name}
            fill
            className="object-cover rounded-lg"
            priority // Prioritize loading the main product image
          />
          {/* TODO: Add gallery/carousel for other images in `imageUrls` if needed */}
        </div>

        <div>
          <h1 className="text-3xl font-bold mb-2">{frontmatter.name}</h1>
          <p className="text-lg text-muted-foreground mb-6">{frontmatter.description}</p>
          
          <div className="space-y-4 mb-8">
            <div className="grid grid-cols-3 gap-4">
              <div className="p-4 border rounded-lg">
                <p className="text-sm text-muted-foreground">Daily</p>
                <p className="text-xl font-semibold">{formatCurrency(frontmatter.dailyPrice)}</p>
              </div>
              <div className="p-4 border rounded-lg">
                <p className="text-sm text-muted-foreground">Weekend</p>
                <p className="text-xl font-semibold">{formatCurrency(frontmatter.weekendPrice)}</p>
              </div>
              <div className="p-4 border rounded-lg">
                <p className="text-sm text-muted-foreground">Weekly</p>
                <p className="text-xl font-semibold">{formatCurrency(frontmatter.weeklyPrice)}</p>
              </div>
            </div>
          </div>
          
          <div className="p-4 bg-muted rounded-lg mb-8">
            <p className="font-medium mb-1">Deposit required</p>
            <p className="text-xl font-semibold">{formatCurrency(frontmatter.deposit)}</p>
          </div>
          
          <button className="w-full bg-primary text-primary-foreground hover:bg-primary/90 py-3 rounded-md font-medium">
            Book Now (Action not implemented)
          </button>
        </div>
      </div>

      <div className="mt-12 prose max-w-none">
         <MDXRemote source={content} />
      </div>
    </div>
  );
} 
--- File: src/app/api/editor/products/route.ts ---

import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';
import { NextRequest, NextResponse } from 'next/server';

const productsDirectory = path.join(process.cwd(), 'content/products');
const imagesBaseDirectory = path.join(process.cwd(), 'public/images/products');

// Helper function to generate a slug (you might want a more robust version)
function generateSlug(name: string): string {
  return name
    .toLowerCase()
    .replace(/\s+/g, '-') // Replace spaces with -
    .replace(/[^\w-]+/g, ''); // Remove all non-word chars
}

export async function GET() {
  if (process.env.NODE_ENV !== 'development') {
    return NextResponse.json(
      { error: 'Forbidden' },
      { status: 403 }
    );
  }

  try {
    const filenames = fs.readdirSync(productsDirectory);
    const products = filenames
      .filter(filename => filename.endsWith('.mdx'))
      .map((filename) => {
        const slug = filename.replace(/\.mdx$/, '');
        const fullPath = path.join(productsDirectory, filename);
        try {
          const fileContents = fs.readFileSync(fullPath, 'utf8');
          const { data } = matter(fileContents);
          return {
            slug,
            name: data.name || 'Unnamed Product', // Provide a fallback for name
          };
        } catch (readError) {
          console.error(`Error reading or parsing ${filename} for editor list:`, readError);
          return {
            slug,
            name: 'Error Reading Product',
          };
        }
      });

    return NextResponse.json(products);
  } catch (error) {
    console.error("Error reading products directory for editor:", error);
    return NextResponse.json(
      { error: 'Failed to retrieve products' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  if (process.env.NODE_ENV !== 'development') {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  try {
    const formData = await request.json();
    const {
      name,
      description,
      category,
      dailyPrice,
      weekendPrice,
      weeklyPrice,
      deposit,
      mdxContent = '' // Default to empty string if not provided
    } = formData;

    // Basic validation
    if (!name || !description || !category || dailyPrice === undefined || weekendPrice === undefined || weeklyPrice === undefined || deposit === undefined) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    const slug = generateSlug(name);
    const filePath = path.join(productsDirectory, `${slug}.mdx`);

    if (fs.existsSync(filePath)) {
      return NextResponse.json({ error: 'Product with this name (slug) already exists' }, { status: 409 });
    }

    const frontmatter = {
      name,
      description,
      category,
      dailyPrice: Number(dailyPrice),
      weekendPrice: Number(weekendPrice),
      weeklyPrice: Number(weeklyPrice),
      deposit: Number(deposit),
      // imageUrl will be handled by image upload later, or derived from the first image in the folder
    };

    const fileContent = matter.stringify(mdxContent, frontmatter);
    fs.writeFileSync(filePath, fileContent);

    // Create image directory for the product
    const productImageDir = path.join(imagesBaseDirectory, slug);
    if (!fs.existsSync(productImageDir)) {
      fs.mkdirSync(productImageDir, { recursive: true });
    }

    return NextResponse.json({ message: 'Product created successfully', slug }, { status: 201 });

  } catch (error) {
    console.error("Error creating product:", error);
    if (error instanceof SyntaxError) { // Handle JSON parsing errors
        return NextResponse.json({ error: 'Invalid JSON payload' }, { status: 400 });
    }
    return NextResponse.json({ error: 'Failed to create product' }, { status: 500 });
  }
}

--- File: src/app/api/editor/products/[slug]/route.ts ---

import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';
import { type NextRequest, NextResponse } from 'next/server';

const productsDirectory = path.join(process.cwd(), 'content/products');
const imagesBaseDirectory = path.join(process.cwd(), 'public/images/products'); // For image handling later

// Helper to extract slug from pathname for this route
function getSlugFromProductPathname(pathname: string): string | undefined {
  // Pathname is like /api/editor/products/some-product-slug
  const parts = pathname.split('/');
  // Expected structure: ['', 'api', 'editor', 'products', 'SLUG']
  if (parts.length >= 5) {
    return parts[parts.length - 1]; // The last part should be the slug
  }
  return undefined;
}

// GET a single product for editing
export async function GET(request: NextRequest) {
  if (process.env.NODE_ENV !== 'development') {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const slug = getSlugFromProductPathname(request.nextUrl.pathname);

  if (!slug) {
    return NextResponse.json({ error: 'Could not determine product slug from URL path' }, { status: 400 });
  }

  const filePath = path.join(productsDirectory, `${slug}.mdx`);

  try {
    if (!fs.existsSync(filePath)) {
      return NextResponse.json({ error: 'Product not found' }, { status: 404 });
    }

    const fileContents = fs.readFileSync(filePath, 'utf8');
    const { data, content } = matter(fileContents);

    return NextResponse.json({ frontmatter: data, content, slug });
  } catch (error) {
    console.error(`Error reading product file ${slug}.mdx:`, error);
    return NextResponse.json({ error: 'Failed to retrieve product' }, { status: 500 });
  }
}

// PUT (update) a product
export async function PUT(request: NextRequest) {
  if (process.env.NODE_ENV !== 'development') {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const slug = getSlugFromProductPathname(request.nextUrl.pathname);

  if (!slug) {
    return NextResponse.json({ error: 'Could not determine product slug from URL path' }, { status: 400 });
  }

  const filePath = path.join(productsDirectory, `${slug}.mdx`);

  try {
    if (!fs.existsSync(filePath)) {
      return NextResponse.json({ error: 'Product not found, cannot update.' }, { status: 404 });
    }

    const formData = await request.json();
    const {
      name,
      description,
      category,
      dailyPrice,
      weekendPrice,
      weeklyPrice,
      deposit,
      mdxContent
    } = formData;

    // Basic validation
    if (name === undefined || description === undefined || category === undefined || dailyPrice === undefined || weekendPrice === undefined || weeklyPrice === undefined || deposit === undefined || mdxContent === undefined) {
      return NextResponse.json({ error: 'Missing required fields for update' }, { status: 400 });
    }

    // Note: We are NOT changing the slug or filename here.
    // If the 'name' changes, the slug derived from it would also change.
    // Handling slug changes (renaming files and potentially image folders) is more complex
    // and can be added as a separate feature or handled with caution.
    // For now, the filename (and thus the slug in the URL) remains constant.

    const frontmatter = {
      name,
      description,
      category,
      dailyPrice: Number(dailyPrice),
      weekendPrice: Number(weekendPrice),
      weeklyPrice: Number(weeklyPrice),
      deposit: Number(deposit),
    };

    const fileContent = matter.stringify(mdxContent, frontmatter);
    fs.writeFileSync(filePath, fileContent);

    return NextResponse.json({ message: 'Product updated successfully', slug });

  } catch (error) {
    console.error(`Error updating product ${slug}.mdx:`, error);
    if (error instanceof SyntaxError) {
        return NextResponse.json({ error: 'Invalid JSON payload' }, { status: 400 });
    }
    return NextResponse.json({ error: 'Failed to update product' }, { status: 500 });
  }
}

// DELETE a product
export async function DELETE(request: NextRequest, { params }: { params: { slug: string } }) {
  if (process.env.NODE_ENV !== 'development') {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const slug = params.slug;
  const mdxFilePath = path.join(productsDirectory, `${slug}.mdx`);
  const imageDirectoryPath = path.join(imagesBaseDirectory, slug);

  try {
    let mdxDeleted = false;
    if (fs.existsSync(mdxFilePath)) {
      fs.unlinkSync(mdxFilePath);
      mdxDeleted = true;
    } else {
      console.warn(`MDX file not found for deletion: ${mdxFilePath}`);
      // We might still want to attempt to delete the image directory
    }

    let imageDirDeleted = false;
    if (fs.existsSync(imageDirectoryPath)) {
      fs.rmSync(imageDirectoryPath, { recursive: true, force: true }); // force: true to suppress errors if dir is empty or not found
      imageDirDeleted = true;
    } else {
      console.warn(`Image directory not found for deletion: ${imageDirectoryPath}`);
    }

    if (!mdxDeleted && !imageDirDeleted) {
        return NextResponse.json({ error: 'Product (MDX and image directory) not found.' }, { status: 404 });
    }

    return NextResponse.json({ message: `Product '${slug}' deleted successfully (MDX: ${mdxDeleted}, Images: ${imageDirDeleted})` });

  } catch (error) {
    console.error(`Error deleting product ${slug}:`, error);
    return NextResponse.json({ error: `Failed to delete product '${slug}'` }, { status: 500 });
  }
}

--- File: src/app/api/editor/products/[slug]/images/route.ts ---

import path from 'path';
import { type NextRequest, NextResponse } from 'next/server';
import { stat, mkdir, writeFile, readdir, unlink } from 'fs/promises'; // Using promise-based fs

const imagesBaseDirectory = path.join(process.cwd(), 'public/images/products');
const imagesPublicPath = '/images/products'; // Public URL path

// Helper to extract slug from pathname
function getSlugFromPathname(pathname: string): string | undefined {
  // Pathname is like /api/editor/products/some-product-slug/images
  const parts = pathname.split('/');
  // Expected structure: ['', 'api', 'editor', 'products', 'SLUG', 'images']
  if (parts.length >= 3 && parts[parts.length - 1] === 'images') {
    return parts[parts.length - 2];
  }
  return undefined;
}

// GET existing images for a product
export async function GET(request: NextRequest) {
  if (process.env.NODE_ENV !== 'development') {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const slug = getSlugFromPathname(request.nextUrl.pathname);

  if (!slug) {
    return NextResponse.json({ error: 'Could not determine product slug from URL path' }, { status: 400 });
  }

  const productImageDir = path.join(imagesBaseDirectory, slug);

  try {
    await stat(productImageDir);
    const imageFilenames = await readdir(productImageDir);
    const sortedImageFiles = imageFilenames
      .filter(filename => /\.(jpg|jpeg|png|webp|gif)$/i.test(filename))
      .sort((a, b) => a.localeCompare(b));

    const imageUrls = sortedImageFiles.map(filename => `${imagesPublicPath}/${slug}/${filename}`);
    return NextResponse.json(imageUrls);
  } catch (error: unknown) {
    if (error instanceof Error && 'code' in error && (error as NodeJS.ErrnoException).code === 'ENOENT') {
      return NextResponse.json([]);
    }
    console.error(`Error reading images for product ${slug}:`, error);
    return NextResponse.json({ error: `Failed to retrieve images for ${slug}` }, { status: 500 });
  }
}

// POST (upload) new images for a product
export async function POST(request: NextRequest) {
  if (process.env.NODE_ENV !== 'development') {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const slug = getSlugFromPathname(request.nextUrl.pathname);

  if (!slug) {
    return NextResponse.json({ error: 'Could not determine product slug from URL path' }, { status: 400 });
  }

  const productImageDir = path.join(imagesBaseDirectory, slug);

  try {
    await mkdir(productImageDir, { recursive: true });
    const formData = await request.formData();
    const files = formData.getAll('images') as File[];

    if (!files || files.length === 0) {
      return NextResponse.json({ error: 'No files provided' }, { status: 400 });
    }

    const uploadedFilePaths: string[] = [];
    for (const file of files) {
      if (!(file instanceof File)) {
        console.warn('Skipping non-file entry in FormData');
        continue;
      }
      if (!/\.(jpg|jpeg|png|webp|gif)$/i.test(file.name)) {
          console.warn(`Skipping file with unsupported type: ${file.name}`);
          continue;
      }
      const bytes = await file.arrayBuffer();
      const buffer = Buffer.from(bytes);
      const filePath = path.join(productImageDir, file.name);
      await writeFile(filePath, buffer);
      uploadedFilePaths.push(`${imagesPublicPath}/${slug}/${file.name}`);
    }

    if (uploadedFilePaths.length === 0) {
        return NextResponse.json({ error: 'No valid image files were uploaded.'} , { status: 400});
    }

    return NextResponse.json({ message: 'Images uploaded successfully', uploadedFilePaths }, { status: 201 });
  } catch (error) {
    console.error(`Error uploading images for product ${slug}:`, error);
    return NextResponse.json({ error: `Failed to upload images for ${slug}` }, { status: 500 });
  }
}

// DELETE a specific image for a product
export async function DELETE(request: NextRequest) {
  if (process.env.NODE_ENV !== 'development') {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  const slug = getSlugFromPathname(request.nextUrl.pathname);
  const filename = request.nextUrl.searchParams.get('filename');

  if (!slug) {
    return NextResponse.json({ error: 'Could not determine product slug from URL path' }, { status: 400 });
  }
  if (!filename) {
    return NextResponse.json({ error: 'Filename query parameter is required' }, { status: 400 });
  }

  const imagePath = path.join(imagesBaseDirectory, slug, filename);

  try {
    await stat(imagePath);
    await unlink(imagePath);
    return NextResponse.json({ message: `Image '${filename}' deleted successfully from product '${slug}'` });
  } catch (error: unknown) {
    if (error instanceof Error && 'code' in error && (error as NodeJS.ErrnoException).code === 'ENOENT') {
      return NextResponse.json({ error: `Image '${filename}' not found for product '${slug}'` }, { status: 404 });
    }
    console.error(`Error deleting image '${filename}' for product ${slug}:`, error);
    return NextResponse.json({ error: `Failed to delete image '${filename}'` }, { status: 500 });
  }
}

--- File: src/app/editor/page.tsx ---

"use client";

import { useState, useEffect, useCallback } from 'react';
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { Card, CardHeader, CardTitle, CardDescription, CardFooter } from '@/components/ui/card';

interface EditorProduct {
  slug: string;
  name: string;
}

export default function EditorPage() {
  const [products, setProducts] = useState<EditorProduct[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [actionMessage, setActionMessage] = useState<string | null>(null);
  const [isDevelopment, setIsDevelopment] = useState(false);

  const fetchProducts = useCallback(async () => {
    if (process.env.NODE_ENV !== 'development') {
      setIsLoading(false);
      return;
    }
    setIsLoading(true);
    setError(null);
    setActionMessage(null);
    try {
      const response = await fetch('/api/editor/products');
      if (!response.ok) {
        throw new Error(`Failed to fetch products: ${response.statusText}`);
      }
      const data = await response.json();
      setProducts(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err));
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    setIsDevelopment(process.env.NODE_ENV === 'development');
    if (process.env.NODE_ENV === 'development') {
      fetchProducts();
    } else {
      setIsLoading(false);
    }
  }, [fetchProducts]);

  const handleDeleteProduct = async (slug: string, productName: string) => {
    if (process.env.NODE_ENV !== 'development') {
      setActionMessage("Deletion is only allowed in development.");
      return;
    }

    if (!window.confirm(`Are you sure you want to delete "${productName}"? This action cannot be undone.`)) {
      return;
    }

    setActionMessage(null);
    setError(null);

    try {
      const response = await fetch(`/api/editor/products/${slug}`, {
        method: 'DELETE',
      });
      const result = await response.json();
      if (!response.ok) {
        throw new Error(result.error || `Failed to delete product: ${response.statusText}`);
      }
      setActionMessage(result.message || `Product "${productName}" deleted successfully.`);
      fetchProducts();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unknown error occurred during deletion.');
      setActionMessage(null);
    }
  };

  if (!isDevelopment) {
    return (
      <div className="container mx-auto px-4 py-8 text-center">
        <h1 className="text-2xl font-bold">Editor Unavailable</h1>
        <p>This editor is only available in the development environment.</p>
      </div>
    );
  }

  if (isLoading && products.length === 0) {
    return <div className="container mx-auto px-4 py-8">Loading editor...</div>;
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex justify-between items-center mb-8">
        <h1 className="text-3xl font-bold">Product Editor</h1>
        <Link href="/editor/new" passHref>
          <Button>Create New Product</Button>
        </Link>
      </div>

      {actionMessage && <p className={`mb-4 p-3 rounded-md ${error ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700'}`}>{actionMessage}</p>}
      {error && !actionMessage && <p className="mb-4 p-3 rounded-md bg-red-100 text-red-700">Error: {error}</p>}

      {products.length === 0 && !isLoading ? (
        <p>No products found. Start by creating one!</p>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {products.map((product) => (
            <Card key={product.slug}>
              <CardHeader>
                <CardTitle>{product.name}</CardTitle>
                <CardDescription>Slug: {product.slug}</CardDescription>
              </CardHeader>
              <CardFooter className="flex justify-end gap-2">
                <Link href={`/editor/edit/${product.slug}`} passHref>
                   <Button variant="outline" size="sm">Edit</Button>
                </Link>
                <Button
                  variant="destructive"
                  size="sm"
                  onClick={() => handleDeleteProduct(product.slug, product.name)}
                >
                  Delete
                </Button>
              </CardFooter>
            </Card>
          ))}
        </div>
      )}
    </div>
  );
}

--- File: src/app/editor/edit/[slug]/page.tsx ---

"use client";

import { useState, useEffect, useCallback, ChangeEvent } from 'react';
import { useParams } from 'next/navigation';
import Image from 'next/image';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardHeader, CardTitle, CardFooter, CardDescription } from '@/components/ui/card';
import Link from 'next/link';

interface ProductData {
  name: string;
  description: string;
  category: string;
  dailyPrice: string | number; // Allow string for form input, convert to number on submit
  weekendPrice: string | number;
  weeklyPrice: string | number;
  deposit: string | number;
  mdxContent: string;
}

export default function EditProductPage() {
  const params = useParams();
  const slug = typeof params.slug === 'string' ? params.slug : '';

  const [formData, setFormData] = useState<ProductData | null>(null);
  const [productImages, setProductImages] = useState<string[]>([]);
  const [selectedFiles, setSelectedFiles] = useState<FileList | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  
  const [isLoading, setIsLoading] = useState(true);
  const [isLoadingImages, setIsLoadingImages] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const [error, setError] = useState<string | null>(null);
  const [imageError, setImageError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const [imageSuccessMessage, setImageSuccessMessage] = useState<string | null>(null);

  const [isDevelopment, setIsDevelopment] = useState(false);

  useEffect(() => {
    setIsDevelopment(process.env.NODE_ENV === 'development');
  }, []);

  const fetchProductData = useCallback(async () => {
    if (!slug || !isDevelopment) {
      setIsLoading(false);
      if (!isDevelopment) setError("Editing is only available in development.");
      else setError("No product slug provided.");
      return;
    }
    setIsLoading(true);
    setError(null);
    setSuccessMessage(null);
    try {
      const response = await fetch(`/api/editor/products/${slug}`);
      if (!response.ok) {
        const errData = await response.json();
        throw new Error(errData.error || `Failed to fetch product data: ${response.statusText}`);
      }
      const data = await response.json();
      setFormData({
        name: data.frontmatter.name,
        description: data.frontmatter.description,
        category: data.frontmatter.category,
        dailyPrice: String(data.frontmatter.dailyPrice),
        weekendPrice: String(data.frontmatter.weekendPrice),
        weeklyPrice: String(data.frontmatter.weeklyPrice),
        deposit: String(data.frontmatter.deposit),
        mdxContent: data.content,
      });
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err));
      setFormData(null);
    } finally {
      setIsLoading(false);
    }
  }, [slug, isDevelopment]);

  const fetchProductImages = useCallback(async () => {
    if (!slug || !isDevelopment) {
      setIsLoadingImages(false);
      return;
    }
    setIsLoadingImages(true);
    setImageError(null);
    setImageSuccessMessage(null);
    try {
      const response = await fetch(`/api/editor/products/${slug}/images`);
      if (!response.ok) {
        const errData = await response.json();
        throw new Error(errData.error || `Failed to fetch images: ${response.statusText}`);
      }
      const data = await response.json();
      setProductImages(data);
    } catch (err) {
      setImageError(err instanceof Error ? err.message : String(err));
      setProductImages([]);
    } finally {
      setIsLoadingImages(false);
    }
  }, [slug, isDevelopment]);

  useEffect(() => {
    if (isDevelopment) {
      fetchProductData();
      fetchProductImages();
    } else {
      setIsLoading(false);
      setIsLoadingImages(false);
      setError("Editing is only available in development.");
    }
  }, [fetchProductData, fetchProductImages, isDevelopment]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData(prev => (prev ? { ...prev, [name]: value } : null));
  };

  const handleSubmitMdx = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!isDevelopment || !formData) {
      setError("Form submission is only allowed in development or form data is missing.");
      return;
    }
    setIsSubmitting(true);
    setError(null);
    setSuccessMessage(null);
    try {
      const response = await fetch(`/api/editor/products/${slug}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            ...formData,
            dailyPrice: parseFloat(String(formData.dailyPrice)) || 0,
            weekendPrice: parseFloat(String(formData.weekendPrice)) || 0,
            weeklyPrice: parseFloat(String(formData.weeklyPrice)) || 0,
            deposit: parseFloat(String(formData.deposit)) || 0,
        }),
      });
      const result = await response.json();
      if (!response.ok) throw new Error(result.error || `Server responded with ${response.status}`);
      setSuccessMessage(`Product "${formData.name}" details updated successfully!`);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unknown error occurred.');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleFileChange = (e: ChangeEvent<HTMLInputElement>) => {
    setSelectedFiles(e.target.files);
  };

  const handleImageUpload = async () => {
    if (!selectedFiles || selectedFiles.length === 0 || !isDevelopment) {
      setImageError("Please select files to upload and ensure you are in development mode.");
      return;
    }
    setIsUploading(true);
    setImageError(null);
    setImageSuccessMessage(null);
    const imageFormData = new FormData();
    for (let i = 0; i < selectedFiles.length; i++) {
      imageFormData.append('images', selectedFiles[i]);
    }

    try {
      const response = await fetch(`/api/editor/products/${slug}/images`, {
        method: 'POST',
        body: imageFormData,
      });
      const result = await response.json();
      if (!response.ok) throw new Error(result.error || `Server responded with ${response.status}`);
      setImageSuccessMessage(result.message || 'Images uploaded successfully!');
      fetchProductImages();
      setSelectedFiles(null);
      const fileInput = document.getElementById('imageUploadInput') as HTMLInputElement;
      if (fileInput) fileInput.value = '';
    } catch (err) {
      setImageError(err instanceof Error ? err.message : 'An unknown error occurred during upload.');
    } finally {
      setIsUploading(false);
    }
  };

  const handleImageDelete = async (imageUrl: string) => {
    if (!isDevelopment) {
        setImageError("Image deletion is only allowed in development.");
        return;
    }
    const filename = imageUrl.substring(imageUrl.lastIndexOf('/') + 1);
    if (!window.confirm(`Are you sure you want to delete image: ${filename}?`)) return;

    setImageError(null);
    setImageSuccessMessage(null);
    try {
      const response = await fetch(`/api/editor/products/${slug}/images?filename=${encodeURIComponent(filename)}`, {
        method: 'DELETE',
      });
      const result = await response.json();
      if (!response.ok) throw new Error(result.error || `Server responded with ${response.status}`);
      setImageSuccessMessage(result.message || 'Image deleted successfully!');
      fetchProductImages();
    } catch (err) {
      setImageError(err instanceof Error ? err.message : 'An unknown error occurred during deletion.');
    }
  };
  
  if (!isDevelopment && !isLoading && !isLoadingImages) {
    return (
      <div className="container mx-auto px-4 py-8 text-center">
        <h1 className="text-2xl font-bold">Editor Unavailable</h1>
        <p>This feature is only available in the development environment.</p>
      </div>
    );
  }

  if (isLoading) {
    return <div className="container mx-auto px-4 py-8">Loading product details...</div>;
  }

  if (error && !formData) {
    return (
        <div className="container mx-auto px-4 py-8">
            <p className="text-red-500 bg-red-100 p-3 rounded-md mb-4">Error loading product data: {error}</p>
            <Link href="/editor" passHref><Button variant="outline">Back to Editor</Button></Link>
        </div>
    );
  }
  
  if (!formData) {
      return <div className="container mx-auto px-4 py-8">Product data could not be loaded or does not exist.</div>;
  }

  return (
    <div className="container mx-auto px-4 py-8 max-w-3xl">
      <Card className="mb-8">
        <CardHeader>
          <CardTitle>Edit: {formData.name}</CardTitle>
          <CardDescription>Modify the details for product (slug: {slug}).</CardDescription>
        </CardHeader>
        <form onSubmit={handleSubmitMdx}>
          <CardContent className="space-y-6">
            {error && <p className="text-red-500 bg-red-100 p-3 rounded-md">{error}</p>}
            {successMessage && <p className="text-green-500 bg-green-100 p-3 rounded-md">{successMessage}</p>}

            <div><Label htmlFor="name">Product Name</Label><Input id="name" name="name" value={formData.name} onChange={handleChange} required /></div>
            <div><Label htmlFor="description">Description</Label><Textarea id="description" name="description" value={formData.description} onChange={handleChange} required /></div>
            <div><Label htmlFor="category">Category</Label><Input id="category" name="category" value={formData.category} onChange={handleChange} required /></div>
            <div className="grid grid-cols-2 gap-4">
              <div><Label htmlFor="dailyPrice">Daily Price</Label><Input id="dailyPrice" name="dailyPrice" type="number" value={formData.dailyPrice} onChange={handleChange} required /></div>
              <div><Label htmlFor="weekendPrice">Weekend Price</Label><Input id="weekendPrice" name="weekendPrice" type="number" value={formData.weekendPrice} onChange={handleChange} required /></div>
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div><Label htmlFor="weeklyPrice">Weekly Price</Label><Input id="weeklyPrice" name="weeklyPrice" type="number" value={formData.weeklyPrice} onChange={handleChange} required /></div>
              <div><Label htmlFor="deposit">Deposit</Label><Input id="deposit" name="deposit" type="number" value={formData.deposit} onChange={handleChange} required /></div>
            </div>
            <div><Label htmlFor="mdxContent">MDX Content</Label><Textarea id="mdxContent" name="mdxContent" value={formData.mdxContent} onChange={handleChange} rows={10}/></div>

          </CardContent>
          <CardFooter className="flex justify-between">
            <Button type="submit" disabled={isSubmitting}>
              {isSubmitting ? 'Updating Details...' : 'Save Details'}
            </Button>
            <Link href="/editor" passHref>
                <Button type="button" variant="outline">Back to Editor</Button>
            </Link>
          </CardFooter>
        </form>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Manage Product Images</CardTitle>
        </CardHeader>
        <CardContent className="space-y-6">
          {imageError && <p className="text-red-500 bg-red-100 p-3 rounded-md">{imageError}</p>}
          {imageSuccessMessage && <p className="text-green-500 bg-green-100 p-3 rounded-md">{imageSuccessMessage}</p>}

          <div className="space-y-2">
            <Label htmlFor="imageUploadInput">Upload New Images</Label>
            <div className="flex gap-2">
              <Input 
                id="imageUploadInput" 
                type="file" 
                multiple 
                onChange={handleFileChange} 
                accept="image/jpeg,image/png,image/webp,image/gif"
                className="flex-grow"
              />
              <Button onClick={handleImageUpload} disabled={isUploading || !selectedFiles || selectedFiles.length === 0}>
                {isUploading ? 'Uploading...' : 'Upload Selected'}
              </Button>
            </div>
            {selectedFiles && selectedFiles.length > 0 && (
                <p className="text-sm text-muted-foreground">
                    {selectedFiles.length} file(s) selected.
                </p>
            )}
          </div>

          <div>
            <h3 className="text-lg font-medium mb-2">Current Images</h3>
            {isLoadingImages ? (
              <p>Loading images...</p>
            ) : productImages.length > 0 ? (
              <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4">
                {productImages.map((imageUrl) => (
                  <div key={imageUrl} className="relative group border rounded-md overflow-hidden">
                    <Image
                      src={imageUrl}
                      alt={`Product Image for ${slug}`}
                      width={200}
                      height={200}
                      className="object-cover aspect-square"
                    />
                    <Button
                      variant="destructive"
                      size="sm"
                      className="absolute top-1 right-1 opacity-0 group-hover:opacity-100 transition-opacity"
                      onClick={() => handleImageDelete(imageUrl)}
                    >
                      Delete
                    </Button>
                  </div>
                ))}
              </div>
            ) : (
              <p>No images found for this product.</p>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

--- File: src/app/editor/new/page.tsx ---

"use client";

import { useState, useEffect, ChangeEvent, FormEvent } from 'react';
import { useRouter } from 'next/navigation';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardHeader, CardTitle, CardFooter, CardDescription } from '@/components/ui/card';

export default function NewProductPage() {
  const router = useRouter();
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    category: '',
    dailyPrice: '',
    weekendPrice: '',
    weeklyPrice: '',
    deposit: '',
    mdxContent: '## Product Specifications\n\n## Usage Instructions\n'
  });
  const [selectedFiles, setSelectedFiles] = useState<FileList | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submissionStatus, setSubmissionStatus] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isDevelopment, setIsDevelopment] = useState(false);

  useEffect(() => {
    setIsDevelopment(process.env.NODE_ENV === 'development');
  }, []);

  const handleChange = (e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleFileChange = (e: ChangeEvent<HTMLInputElement>) => {
    setSelectedFiles(e.target.files);
  };

  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!isDevelopment) {
      setError("Form submission is only allowed in development.");
      return;
    }

    setIsSubmitting(true);
    setError(null);
    setSubmissionStatus("Creating product details...");
    let productSlug = '';

    // --- Step 1: Create Product MDX ---
    try {
      const createResponse = await fetch('/api/editor/products', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            ...formData,
            dailyPrice: parseFloat(formData.dailyPrice) || 0,
            weekendPrice: parseFloat(formData.weekendPrice) || 0,
            weeklyPrice: parseFloat(formData.weeklyPrice) || 0,
            deposit: parseFloat(formData.deposit) || 0,
        }),
      });
      const createResult = await createResponse.json();
      if (!createResponse.ok) {
        throw new Error(createResult.error || `Failed to create product: Server responded with ${createResponse.status}`);
      }
      productSlug = createResult.slug; // Store slug for image upload and redirect
      setSubmissionStatus(`Product "${formData.name}" created (slug: ${productSlug}).`);

    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unknown error occurred during product creation.');
      setIsSubmitting(false);
      setSubmissionStatus(null);
      return; // Stop if product creation failed
    }

    // --- Step 2: Upload Images (if selected) ---
    if (selectedFiles && selectedFiles.length > 0 && productSlug) {
      setSubmissionStatus(`Uploading ${selectedFiles.length} image(s)...`);
      const imageFormData = new FormData();
      for (let i = 0; i < selectedFiles.length; i++) {
        imageFormData.append('images', selectedFiles[i]);
      }

      try {
        const uploadResponse = await fetch(`/api/editor/products/${productSlug}/images`, {
          method: 'POST',
          body: imageFormData,
        });
        const uploadResult = await uploadResponse.json();
        if (!uploadResponse.ok) {
          // Don't throw error here, just report it. Product already created.
          setError(`Product created, but image upload failed: ${uploadResult.error || `Server responded with ${uploadResponse.status}`}`);
          setSubmissionStatus(null); // Clear status message
        } else {
          setSubmissionStatus(`Product created and images uploaded successfully! Redirecting...`);
        }
      } catch (uploadErr) {
        setError(`Product created, but an error occurred during image upload: ${uploadErr instanceof Error ? uploadErr.message : String(uploadErr)}`);
        setSubmissionStatus(null);
      }
    } else {
        setSubmissionStatus(`Product created successfully (no images selected). Redirecting...`);
    }

    // --- Step 3: Redirect (after a short delay to show final status) ---
    setTimeout(() => {
        if (productSlug) {
            router.push(`/editor/edit/${productSlug}`);
        } else {
            // Fallback if slug wasn't obtained (shouldn't happen if create succeeded)
            setError("Could not determine product slug for redirect.");
            setIsSubmitting(false);
        }
        // Don't set isSubmitting to false here as we are navigating away
    }, 1500); // 1.5 second delay

  };

  if (!isDevelopment) {
    return (
      <div className="container mx-auto px-4 py-8 text-center">
        <h1 className="text-2xl font-bold">Editor Unavailable</h1>
        <p>This feature is only available in the development environment.</p>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8 max-w-2xl">
      <Card>
        <CardHeader>
          <CardTitle>Create New Product</CardTitle>
          <CardDescription>Fill in the details and optionally upload initial images.</CardDescription>
        </CardHeader>
        <form onSubmit={handleSubmit}>
          <CardContent className="space-y-6">
              {submissionStatus && !error && <p className="text-blue-600 bg-blue-100 p-3 rounded-md">{submissionStatus}</p>}
              {error && <p className="text-red-500 bg-red-100 p-3 rounded-md">{error}</p>}

              <div><Label htmlFor="name">Product Name</Label><Input id="name" name="name" value={formData.name} onChange={handleChange} required disabled={isSubmitting}/></div>
              <div><Label htmlFor="description">Description</Label><Textarea id="description" name="description" value={formData.description} onChange={handleChange} required disabled={isSubmitting}/></div>
              <div><Label htmlFor="category">Category</Label><Input id="category" name="category" value={formData.category} onChange={handleChange} required disabled={isSubmitting}/></div>
              <div className="grid grid-cols-2 gap-4">
                <div><Label htmlFor="dailyPrice">Daily Price</Label><Input id="dailyPrice" name="dailyPrice" type="number" value={formData.dailyPrice} onChange={handleChange} required disabled={isSubmitting}/></div>
                <div><Label htmlFor="weekendPrice">Weekend Price</Label><Input id="weekendPrice" name="weekendPrice" type="number" value={formData.weekendPrice} onChange={handleChange} required disabled={isSubmitting}/></div>
              </div>
              <div className="grid grid-cols-2 gap-4">
                <div><Label htmlFor="weeklyPrice">Weekly Price</Label><Input id="weeklyPrice" name="weeklyPrice" type="number" value={formData.weeklyPrice} onChange={handleChange} required disabled={isSubmitting}/></div>
                <div><Label htmlFor="deposit">Deposit</Label><Input id="deposit" name="deposit" type="number" value={formData.deposit} onChange={handleChange} required disabled={isSubmitting}/></div>
              </div>
              <div><Label htmlFor="mdxContent">MDX Content</Label><Textarea id="mdxContent" name="mdxContent" value={formData.mdxContent} onChange={handleChange} rows={10} placeholder="Enter product details..." disabled={isSubmitting}/></div>

              <div className="space-y-2">
                  <Label htmlFor="images">Initial Images (Optional)</Label>
                  <Input
                      id="images"
                      name="images"
                      type="file"
                      multiple
                      onChange={handleFileChange}
                      accept="image/jpeg,image/png,image/webp,image/gif"
                      disabled={isSubmitting}
                  />
                  {selectedFiles && selectedFiles.length > 0 && (
                      <p className="text-sm text-muted-foreground">
                          {selectedFiles.length} file(s) selected.
                      </p>
                  )}
              </div>

            </CardContent>
            <CardFooter>
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? (submissionStatus || 'Processing...') : 'Create Product & Upload Images'}
              </Button>
              <Button type="button" variant="outline" onClick={() => router.back()} className="ml-2" disabled={isSubmitting}>
                  Cancel
              </Button>
            </CardFooter>
          </form>
        </Card>
      </div>
    );
}

--- File: src/components/product-card.tsx ---

import Image from 'next/image';
import Link from 'next/link';
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from './ui/card';
import { formatCurrency } from '@/lib/utils';

interface ProductCardProps {
  product: {
    name: string;
    description: string;
    imageUrls: string[];
    dailyPrice: number;
    slug: string;
  };
}

export function ProductCard({ product }: ProductCardProps) {
  const primaryImageUrl = product.imageUrls && product.imageUrls.length > 0
    ? product.imageUrls[0]
    : '/images/placeholder.png';

  return (
    <Link href={`/products/${product.slug}`} className="block h-full">
      <Card className="overflow-hidden h-full transition-all hover:shadow-md flex flex-col">
        <div className="aspect-square relative w-full">
          <Image
            src={primaryImageUrl}
            alt={product.name}
            fill
            className="object-cover"
            sizes="(max-width: 640px) 100vw, (max-width: 768px) 50vw, (max-width: 1024px) 33vw, 25vw"
          />
        </div>
        <div className="flex flex-col flex-grow p-4">
          <CardHeader className="p-0 mb-2">
            <CardTitle className="text-xl font-medium">{product.name}</CardTitle>
          </CardHeader>
          <CardContent className="p-0 flex-grow">
            <p className="text-sm text-muted-foreground line-clamp-2">
              {product.description}
            </p>
          </CardContent>
          <CardFooter className="p-0 mt-4">
            <p className="font-medium text-primary">
              {formatCurrency(product.dailyPrice)}/day
            </p>
          </CardFooter>
        </div>
      </Card>
    </Link>
  );
} 
--- File: src/components/product-search.tsx ---

"use client";

import { useState, useEffect } from 'react';
import { Input } from '@/components/ui/input';
import { ProductCard } from '@/components/product-card';

interface Product {
  name: string;
  description: string;
  imageUrls: string[];
  dailyPrice: number;
  slug: string;
  category: string;
}

export function ProductSearch({ products }: { products: Product[] }) {
  const [searchTerm, setSearchTerm] = useState('');
  const [filteredProducts, setFilteredProducts] = useState(products);

  useEffect(() => {
    const results = products.filter(product =>
      product.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      product.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
      product.category.toLowerCase().includes(searchTerm.toLowerCase())
    );
    setFilteredProducts(results);
  }, [searchTerm, products]);

  return (
    <div>
      <div className="mb-6">
        <Input
          type="search"
          placeholder="Search equipment..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="w-full max-w-md"
        />
      </div>

      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
        {filteredProducts.map((product) => (
          <ProductCard key={product.slug} product={product} />
        ))}
      </div>
    </div>
  );
} 
--- File: src/components/ui/card.tsx ---

import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}

--- File: src/components/ui/hover-card.tsx ---

"use client"

import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

function HoverCard({
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Root>) {
  return <HoverCardPrimitive.Root data-slot="hover-card" {...props} />
}

function HoverCardTrigger({
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Trigger>) {
  return (
    <HoverCardPrimitive.Trigger data-slot="hover-card-trigger" {...props} />
  )
}

function HoverCardContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Content>) {
  return (
    <HoverCardPrimitive.Portal data-slot="hover-card-portal">
      <HoverCardPrimitive.Content
        data-slot="hover-card-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-64 origin-(--radix-hover-card-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </HoverCardPrimitive.Portal>
  )
}

export { HoverCard, HoverCardTrigger, HoverCardContent }

--- File: src/components/ui/label.tsx ---

"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }

--- File: src/components/ui/dialog.tsx ---

"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}

--- File: src/components/ui/button.tsx ---

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }

--- File: src/components/ui/textarea.tsx ---

import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }

--- File: src/components/ui/input.tsx ---

import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }

--- File: src/lib/utils.ts ---

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function formatCurrency(amount: number): string {
  return new Intl.NumberFormat('en-DK', {
    style: 'currency',
    currency: 'DKK'
  }).format(amount);
}
